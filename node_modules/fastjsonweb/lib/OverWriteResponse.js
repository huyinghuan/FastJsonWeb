/*
	overwrite the reponse make it easy to use
	the funtions:
		setResponseType(type);
		getResponsetype();
		setHeader(key,value); *important
		setResponseStatus(code); 
		getResponseStatus();
		writeHeaderToResponse();
		write(content,type); *important
		writeToFileByReadableStream(readableStream,filesetting);*important
		render(); *important
*/
var ConfigHelper = require('./ConfigHelper');
//var Engine = require('./renderedEngine').ViewEngine;
var path = require('path');
var fs = require('fs');

var OverWriteResponse = function(response){
	this.data = {
		type:"TXT",
		header:{},
		status:200
	};
	this.__response = response;
};

/*
set the response type
parameters:
	type  Type:string  [necessary parameter]
*/
OverWriteResponse.prototype.setResponseType = function(type){
	if(typeof type === "undefined"){
		return;
	}	
	this.data.type = type;
}

/*	
get the response type
	if the data.type is not exists in MIME.json return the MIME["TXT"]
parameters:
	name  Type:string  [optional parameter]
		if name is undefined  return value that in this.data, else return value of MIME[name]
*/
OverWriteResponse.prototype.getResponsetype = function(name){
	if(!name || typeof name !== "string"){
		var mime =  ConfigHelper.getMime(this.data.type);
		return mime ? mime: ConfigHelper.getMime("TXT");
	}
		
	return ConfigHelper.getMime(name);
};

//set the response type  and save them in this.data.header
OverWriteResponse.prototype.setHeader = function(key,value){

	if(arguments.length = 1 && typeof arguments[0] == "object"){
		var headerObject = arguments[0];
		for(x in  headerObject){
			this.data.header[x] = headerObject[x]
		}
	}else{
		this.data.header[key] = value;
	}
};

/*
set the response status code  and save them in this.data.status
parameters:
	code  Type:number  [necessary parameter]
		the code is a number that the http status code . for example: 200,304,404,500 and so on. 
		if this function not be called ,the status code is 200;
*/
OverWriteResponse.prototype.setResponseStatus = function(code){
	this.data.status = (typeof code === "number" || +code === code )? +code : 200;
};

//get the response status code
OverWriteResponse.prototype.getResponseStatus = function(){
	return this.data.status;
};

//write http header to response
OverWriteResponse.prototype.writeHeaderToResponse = function(){
	for(var headinfo in this.data.header){
		this.__response.setHeader(headinfo,this.data.header[headinfo]);
	}
};

/*
write the content to response.
parameters:
	content  Type:Object  [optional parameter]   
		the message that send to client
		if content is an object , replace  content into  JSON.stringify(content)

	type     Type:string  [optional parameter]  default: TXT
	    the response type  See  MIME.json
*/
OverWriteResponse.prototype.write = function(content,type){
	if(type && typeof type === "string") 
		this.setResponseType(type.toLocaleUpperCase());
	this.writeHeaderToResponse();
	if(typeof content === "undefined"){
		this.__response.end();
		return;
	}
	var respContent = typeof content === "string" ? content : JSON.stringify(content);
	this.__response.writeHead(this.getResponseStatus,{
	//	'Content-Length':respContent.length,
		'Content-Type' : this.getResponsetype()
	});
	this.__response.write(respContent);
	this.__response.end();
};

/*
write readableStream into respone and then send them to client
parameters:
	readableStream  See The NodeJS API ---- Class: stream.Readable
	filesetting   Type:Object
		download   Type:Bool   [optional parameter]  default:false
			true,download file the brower ,otherwise  open the file on the brower,
		filename   Type: string [optional parameter]  default : "_blank"
			the filename on client ,for example: hello.doc.
		fileType   Type: string   [optional parameter]
			the file's MIME in MIME.json
			it's invalid when applicationType was set. see applicationType
		applicationType Type: string   [optional parameter]
			if the file's MIME type is specific and not in MIME.JSON ,you can set the file's MIME type by yourself
			if specific is exists,the fileType setting is invalid.
		    if both of fileType and applicationType is  null or undefined, the file's MIME type is "application/octet-stream"
*/
OverWriteResponse.prototype.writeToFileByReadableStream = function(readableStream,filesetting){ //写文件
	this.writeHeaderToResponse();
	var openmethed = filesetting.download ? "attachment" : "inline";
	var filename = filesetting.filename ? (filesetting.filename+"") : "_blank";
	this.__response.setHeader("Content-Disposition", openmethed+";filename=\"" + filename + "\"");
	//Set the file type
	var contentType = "";
	if(filesetting.fileType && typeof filesetting.fileType === "string"){
		contentType =  this.getResponsetype(filesetting.fileType.toLocaleUpperCase());
	}
	if(filesetting.applicationType && typeof filesetting.applicationType === "string"){
		contentType = filesetting.applicationType;
	}

	if(!contentType || !contentType.length){
		contentType = "application/octet-stream";
	}
	this.__response.writeHead(200, {"Content-Type": contentType});
	readableStream.pipe(this.__response);
	readableStream.on("end", function() {
		this.__response.end();
	});
};

/*
	read the server's file at path  and then write them into respone and then send them to client
		Throw a Error when the path is not exist ;
	parameters:
		path Type:string .  [optional parameter]
			the file path in server. 
		filesetting Type:Object
			the same with writeToFileByReadableStream's
*/
OverWriteResponse.prototype.writeToFileByPath = function(path,filesetting){
	var exists = fs.existsSync(path);
	if (exists) {
		var fileStream = fs.createReadStream(path);
		this.writeToFileByReadableStream(fileStream,filesetting);
	}else{
		throw new Error(path + "is ");
	}
};

/*
	Get 
*/
OverWriteResponse.prototype.getResponse = function(){
	return this.__response;
};

/*
	the same with the the original respone's function 'end' of NodeJS 
*/
OverWriteResponse.prototype.end = function(){
	this.writeHeaderToResponse();
	this.__response.end.apply(null, arguments)
};
/*
OverWriteResponse.prototype.render = function(relativepath,locals){
	for(headinfo in this.data.header){
		response.setHeader(headinfo,this.data.header[headinfo]);
	}
	var engine = new Engine();
	var realpath = path.join(process.cwd(),engine.getViewEngineViewPath());
	var filename = path.join(realpath,relativepath)+"."+engine.getViewEngineSuffix();
	fs.exists(filename, function(exists) {
	    if (exists) {
		    fs.readFile(filename, 'utf8', function (err, data) {
        		if (err) throw err;
        		response.writeHead(200, {"Content-Type": "text/html"});
          		response.write(engine.render(data,locals));
        		response.end();
   			});
	    }else{
		    response.writeHead(200, {"Content-Type": "text/plain"});
		    response.end("Not File");
	    }
  	});
}*/

module.exports = OverWriteResponse;