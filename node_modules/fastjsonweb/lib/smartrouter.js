//路径相似算法
function similar(orig,target){
	//if(target.indexOf("*") === -1 && orig !== target)//如匹配字符串中不包含字符 * ,并且不等于默认字符串，则路径无效
	//	return null; 	
	target = target.replace(/\*{1,}/g,"(.+)");
	var reg = new RegExp(target);
	var arr = orig.match(reg);
	if (!arr) return arr;
	delete arr["index"];
	delete arr["input"];
	arr.shift();
	return arr;
}

function getRealPath(ori,str){
	//var ori = "index";
	/*var str = ["i*in*","*","*ndex","*dex","i*","in*","*de*","*n*dex","index"];
	var str  = {
		"i*in*":"1_{1}_{2}",
		"*":"2_{1}",
		"*ndex":"3_{1}",
		"i*" : "4_{1}",
		"in*" :"5_{1}",
		"*de*":"6_{1}",
		"*n*dex":"7_{1}_{2}"
	}*/
	var min = -1;
	var minarr = [];
	var minstr ="";
	var arr = [];
	/*null ["index"] ["i"]  ["in"]  ["ndex"] ["dex"] ["in", "x"] null  */
    for(i in str){
		if(ori === i){ //如果两个相同则直接使用
			return  str[i];
		}
		arr = similar(ori,i);
	//	console.log(arr);
		if(!arr) continue;
		if(i === "*") continue;
		var arrlength = arr.length;	
		if(min === -1 || arrlength < min){
			min = arrlength;
			minarr = arr;
			minstr  = str[i];
			continue;
		}
		if(min === arrlength){
			for(var j = 0 ; j < min ; j++){
				if(minarr[j].length === arr[j].length) continue;
				if(minarr[j].length < arr[j].length) break;
				min = arrlength;
				minarr = arr;
				minstr  = str[i];
				break;
			}
		}
	}
	if(min == -1){
		if(str["*"]){
			return str["*"].replace(/\{1\}/g,ori);
		}
		return "";
	}
	
	for(var x = 0;x< minarr.length;x++){
		var regR =  "\\{"+(x+1)+"\\}";
		minstr = minstr.replace(new RegExp(regR,"g"),minarr[x]);
	}
	return minstr;
};

exports.getRealPath =  getRealPath;