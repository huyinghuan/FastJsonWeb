var url = require('url');
var path = require('path');
var Assets = require("./Assets");
var Default404Action = require("./action/Default404Action");
var OverWriteResponse = require('./OverWriteResponse');

Router = function(){}

Object.defineProperty(Router,"doFilter",{
	value:function(request,response){
		var ActionObject = this.getAction(request);
		var module = ActionObject.module;
		var method = ActionObject.method;

		var execute = module[method];

		if(execute && typeof execute == "function"){//判断调用方法是否存在
			//	execute.call(request.parameter,request,new NewResponse(response));//call函数 设置 方法的上下文
	  		execute.call(request.parameter,request,new OverWriteResponse(response));
	  		return;
		}
		var errorMessage = "ERROR:"+this.getActionName(request)+"'s method \'"+method+"\' is not exists";
		console.log(errorMessage);
		response.writeHead(500, {
			'Content-Length': errorMessage.length,
			'Content-Type': 'text/plain' 
		});
		response.write(errorMessage);
		response.end();
	}
});

Object.defineProperty(Router,"getAction",{
	value:function(request){
		var pathname = url.parse(request.url).pathname;
		if(this.isStaticResorce(pathname)){
			return this.getAssetsAction();
		}
		return this.getBusinessAction(pathname);
	}
});


Object.defineProperty(Router,"isStaticResorce",{
	value:function(pathname){
		if(!pathname){
			return false;
		}
	//  if(path.indexOf(routerHandle.staticResourceDir) === 0){  //静态资源判断
		if(pathname.indexOf("/public") === 0 || pathname==="/favicon.ico"){  //静态资源判断
			return true;
		}
		return false;
	}
});

Object.defineProperty(Router,"getAssetsAction",{
	value:function(){
		return {
				module:new Assets(),
				method:"execute"
			};
	}

});

Object.defineProperty(Router,"get404Action",{
	value:function(){
		return {
				module:new Default404Action(),
				method:"execute"
			};
	}

});


Object.defineProperty(Router,"getBusinessAction",{
	value:function(pathname){
		//从URL 中解析出 需调用的方法，若没有则默认执行execute方法
		var arr = pathname.split('\!'); 
		if(arr.length > 2){
			var errorMessage = "ERROR: The path \'"
				+pathname.substr(pathname.lastIndexOf('\/')+1,pathname.length)
				+"\' is wrong at \'!\',there is two \'!\' or more.";
			console.log(errorMessage);
		}else if(arr.length == 1){
			arr[1] = "execute";
		}
		var moudleName = arr[0];
		var method = arr[1];
		var modulePath = this.getModuleDiskPath(moudleName);
		var Module = null;
		if(modulePath.indexOf(process.cwd()) == 0 && ( modulePath.length - process.cwd().length) < 2){
			var errorMessage = moudleName+ " is not exist ";
			console.log(errorMessage);
			return this.get404Action();
		}
		console.log(modulePath +"==="+process.cwd());
		Module = require(modulePath);
		return {
			module:new Module(),
			method:method
		}
	}
});

Object.defineProperty(Router,"getModuleDiskPath",{
	value:function(MoudleName){
		var routerMapping = this.getRouterMapping();
		var relativePath;
		//如果是非匹配模式
		if(!this.isSmartRouter()){
			relativePath =  routerMapping[MoudleName] ? routerMapping[MoudleName] : "";
			
		}else{
			//自动模式
			relativePath = this.getMatchStringSimilarPath(MoudleName,routerMapping);
		}	
		return path.join(process.cwd(),relativePath);
	}
});

Object.defineProperty(Router,"getRouterMapping",{
	value:function(){
		return {
			"*" :"{1}"
		};
	}
});

Object.defineProperty(Router,"isSmartRouter",{
	value:function(){
		return true;
	}
});

//用字符串匹配*，从而找出 *所代表的内容。
/*
IndexHello , Ind*ll* ===>["exHe", "o"]
IndexHello , IndexHello ===>[]
IndexHello , *  ===> [IndexHello]
IndexHello , adb*  ===> null
IndexHello , Index*Hello  ===> null
*
*/ 
Object.defineProperty(Router,"getMatchStringArray",{
	value:function(origin,target){
		//替换* 为 (.+) 以便构成正则表达式
		target = target.replace(/\*{1,}/g,"(.+)");
		var reg = new RegExp(target);
		var arr = origin.match(reg);
		if (!arr){
			return arr;
		}
		/** 是一个Object的输出，拥有index 和 input 属性**/
		delete arr["index"];
		delete arr["input"];
		
		//数组的首个元素是原字符串origin,需要排除
		arr.shift();
		return arr;
	}
});

/*
*根据返回内容 计算相似度。
*具体计算规如下
 	特殊情况：
 		1. -1表示相似度为最小
 		2. 如果 原始路径 和 目标映射 相等 ，则相似度最大，直接返回。不再计后续匹配情况
 		3. 如果有连续两个或着两个以上的*号 则 认为只有一个
		4. 如果存在两个一样的映射 ，这取后一个。
	一般情况
		1.*在 origin中代表的字符串 占origin 的比重越小 相似度越高.即非*所代表的内容 比重越高 相似度越高
		2. 接上一规则，当占的比重一样时， *号 越少 相似度越高
		3. 接上一个规则，当*号的数量一样时 第一个*所在origin中的索引越小 相似度越高。
		由此得到的相似值计算公式:
			字符串比重：handle.replace(/\×/g,"").length * origin.length
			星号的比重：1 / (handle.split('\*').length) * origin.length
			第一个型号的索引比重: 1 / (handle.indexOf('*') + 1 );
		   
		举例:匹配优先度 高到低
		原路径为 ： index
		index > *ndex > i*dex > *ex > * 
*/
Object.defineProperty(Router,"getMatchStringSimilarPath",{
	value:function(origin,targetMapping){
		var similarity	= -1;
		var similarityTmp = 0;
		var matchStringArrayTemp = null;
		var matchHandle =null;
		var matchStringArray = null;
		for(handle in targetMapping){
			handle = handle.replace(/\*{1,}/g,"*");
			matchStringArrayTemp = this.getMatchStringArray(origin,handle);
			if(!matchStringArrayTemp){ //无任何匹配
				continue;
			}
			similarityTmp = handle.replace(/\*/g,"").length * origin.length 
								+ (1 / (handle.split('\*').length)) * origin.length
								+  1 / (handle.indexOf('*') + 1 );
			if (similarity > similarityTmp){
				continue;
			}
			similarity = similarityTmp;
			matchStringArray = matchStringArrayTemp;
			matchHandle = handle;
		}
		if(!matchStringArray){
			return "";
		}
		var mapString = targetMapping[matchHandle];
		for(var x = 0;x< matchStringArray.length;x++){
			var regR =  "\\{"+(x+1)+"\\}";
			mapString = mapString.replace(new RegExp(regR,"g"),matchStringArray[x]);
		}	
		return mapString;
	}
});
module.exports = Router;